
/* 
 * Copyright (c) 2008-2012, Andy Bierman, All Rights Reserved.
 *
 * Unless required by applicable law or agreed to in writing,
 * software distributed under the License is distributed on an
 * "AS IS" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY
 * KIND, either express or implied.  See the License for the
 * specific language governing permissions and limitations
 * under the License.
 *

*** Generated by yangdump 2.2-4

    Combined SIL module
    module onf-config1.1
    revision 2011-12-07
    namespace urn:onf:of11:config:yang
    organization ONF Config Management Group

 */

#include <xmlstring.h>

#include "procdefs.h"
#include "agt.h"
#include "agt_cb.h"
#include "agt_timer.h"
#include "agt_util.h"
#include "dlq.h"
#include "ncx.h"
#include "ncx_feature.h"
#include "ncxmod.h"
#include "ncxtypes.h"
#include "status.h"
#include "onf-config1.1.h"

/* module static variables */
static ncx_module_t *onf_config1_1_mod;
static obj_template_t *capable_switch_obj;
static val_value_t *capable_switch_val;

/* put your static variables here */

/********************************************************************
* FUNCTION y_onf_config1_1_init_static_vars
* 
* initialize module static variables
* 
********************************************************************/
static void y_onf_config1_1_init_static_vars (void)
{
    onf_config1_1_mod = NULL;
    capable_switch_obj = NULL;
    capable_switch_val = NULL;

    /* init your static variables here */

} /* y_onf_config1_1_init_static_vars */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_id_edit
* 
* Edit database object callback
* Path: /capable-switch/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_configuration_points_configuration_point_id_edit
* 
* Edit database object callback
* Path: /capable-switch/configuration-points/configuration-point/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_configuration_points_configuration_point_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_configuration_points_configuration_point_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_configuration_points_configuration_point_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_configuration_points_configuration_point_uri_edit
* 
* Edit database object callback
* Path: /capable-switch/configuration-points/configuration-point/uri
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_configuration_points_configuration_point_uri_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_configuration_points_configuration_point_uri_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_configuration_points_configuration_point_uri_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_configuration_points_configuration_point_protocol_edit
* 
* Edit database object callback
* Path: /capable-switch/configuration-points/configuration-point/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_configuration_points_configuration_point_protocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_configuration_points_configuration_point_protocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_configuration_points_configuration_point_protocol_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_configuration_points_configuration_point_edit
* 
* Edit database object callback
* Path: /capable-switch/configuration-points/configuration-point
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_configuration_points_configuration_point_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_configuration_points_configuration_point_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_configuration_points_configuration_point_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_configuration_points_edit
* 
* Edit database object callback
* Path: /capable-switch/configuration-points
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_configuration_points_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_configuration_points_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_configuration_points_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_resource_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/resource-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_resource_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_resource_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_resource_id_edit */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_number_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/number
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_number_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint64 number;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_number_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the number var here, change zero */
    number = 0;
    VAL_ULONG(dstval) = number;

    return res;

} /* onf_config1_1_capable_switch_resources_port_number_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_name_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/name
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_name_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *name;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_name_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the name var here, change EMPTY_STRING */
    name = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        name);

    return res;

} /* onf_config1_1_capable_switch_resources_port_name_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_current_rate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/current-rate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_current_rate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint32 current_rate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_current_rate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the current_rate var here, change zero */
    current_rate = 0;
    VAL_UINT(dstval) = current_rate;

    return res;

} /* onf_config1_1_capable_switch_resources_port_current_rate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_max_rate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/max-rate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_max_rate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    uint32 max_rate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_max_rate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the max_rate var here, change zero */
    max_rate = 0;
    VAL_UINT(dstval) = max_rate;

    return res;

} /* onf_config1_1_capable_switch_resources_port_max_rate_get */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_configuration_admin_state_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/configuration/admin-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_configuration_admin_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_configuration_admin_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_configuration_admin_state_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_configuration_no_receive_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/configuration/no-receive
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_configuration_no_receive_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_configuration_no_receive_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_configuration_no_receive_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_configuration_no_forward_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/configuration/no-forward
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_configuration_no_forward_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_configuration_no_forward_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_configuration_no_forward_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_configuration_no_packet_in_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/configuration/no-packet-in
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_configuration_no_packet_in_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_configuration_no_packet_in_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_configuration_no_packet_in_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_configuration_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/configuration
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_configuration_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_configuration_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_configuration_edit */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_state_oper_state_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/state/oper-state
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_state_oper_state_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *oper_state;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_state_oper_state_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the oper_state var here, change enum */
    oper_state = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        oper_state);

    return res;

} /* onf_config1_1_capable_switch_resources_port_state_oper_state_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_state_blocked_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/state/blocked
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_state_blocked_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean blocked;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_state_blocked_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the blocked var here, change TRUE if needed */
    blocked = TRUE;VAL_BOOL(dstval) = blocked;

    return res;

} /* onf_config1_1_capable_switch_resources_port_state_blocked_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_state_live_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/state/live
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_state_live_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean live;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_state_live_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the live var here, change TRUE if needed */
    live = TRUE;VAL_BOOL(dstval) = live;

    return res;

} /* onf_config1_1_capable_switch_resources_port_state_live_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_state_mro
* 
* Make read-only child nodes
* Path: /capable-switch/resources/port/state
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    onf_config1_1_capable_switch_resources_port_state_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /capable-switch/resources/port/state/oper-state */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_oper_state,
        onf_config1_1_capable_switch_resources_port_state_oper_state_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/state/blocked */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_blocked,
        onf_config1_1_capable_switch_resources_port_state_blocked_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/state/live */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_live,
        onf_config1_1_capable_switch_resources_port_state_live_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* onf_config1_1_capable_switch_resources_port_state_mro */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_current_rate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/current/rate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_current_rate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *rate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_current_rate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the rate var here, change enum */
    rate = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        rate);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_current_rate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_current_auto_negotiate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/current/auto-negotiate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_current_auto_negotiate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean auto_negotiate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_current_auto_negotiate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the auto_negotiate var here, change TRUE if needed */
    auto_negotiate = TRUE;VAL_BOOL(dstval) = auto_negotiate;

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_current_auto_negotiate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_current_medium_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/current/medium
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_current_medium_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *medium;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_current_medium_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the medium var here, change enum */
    medium = (const xmlChar *)"copper";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        medium);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_current_medium_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_current_pause_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/current/pause
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_current_pause_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *pause;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_current_pause_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the pause var here, change enum */
    pause = (const xmlChar *)"unsupported";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        pause);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_current_pause_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_current_mro
* 
* Make read-only child nodes
* Path: /capable-switch/resources/port/features/current
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    onf_config1_1_capable_switch_resources_port_features_current_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /capable-switch/resources/port/features/current/rate */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_rate,
        onf_config1_1_capable_switch_resources_port_features_current_rate_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/features/current/auto-negotiate */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_auto_negotiate,
        onf_config1_1_capable_switch_resources_port_features_current_auto_negotiate_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/features/current/medium */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_medium,
        onf_config1_1_capable_switch_resources_port_features_current_medium_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/features/current/pause */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_pause,
        onf_config1_1_capable_switch_resources_port_features_current_pause_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_current_mro */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_rate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/features/advertised/rate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_rate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_rate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_rate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_auto_negotiate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/features/advertised/auto-negotiate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_auto_negotiate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_auto_negotiate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_auto_negotiate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_medium_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/features/advertised/medium
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_medium_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_medium_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_medium_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_pause_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/features/advertised/pause
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_pause_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_pause_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_pause_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/features/advertised
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_edit */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_supported_rate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/supported/rate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_supported_rate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *rate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_supported_rate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the rate var here, change enum */
    rate = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        rate);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_supported_rate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_supported_auto_negotiate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/supported/auto-negotiate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_supported_auto_negotiate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean auto_negotiate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_supported_auto_negotiate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the auto_negotiate var here, change TRUE if needed */
    auto_negotiate = TRUE;VAL_BOOL(dstval) = auto_negotiate;

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_supported_auto_negotiate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_supported_medium_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/supported/medium
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_supported_medium_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *medium;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_supported_medium_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the medium var here, change enum */
    medium = (const xmlChar *)"copper";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        medium);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_supported_medium_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_supported_pause_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/supported/pause
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_supported_pause_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *pause;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_supported_pause_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the pause var here, change enum */
    pause = (const xmlChar *)"unsupported";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        pause);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_supported_pause_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_supported_mro
* 
* Make read-only child nodes
* Path: /capable-switch/resources/port/features/supported
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    onf_config1_1_capable_switch_resources_port_features_supported_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    /* container supported not handled!!! */

    /* add /capable-switch/resources/port/features/supported/auto-negotiate */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_auto_negotiate,
        onf_config1_1_capable_switch_resources_port_features_supported_auto_negotiate_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }
    /* container supported not handled!!! */

    /* add /capable-switch/resources/port/features/supported/pause */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_pause,
        onf_config1_1_capable_switch_resources_port_features_supported_pause_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_supported_mro */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_peer_rate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/advertised-peer/rate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_peer_rate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *rate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_peer_rate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the rate var here, change enum */
    rate = EMPTY_STRING;
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        rate);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_peer_rate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_peer_auto_negotiate_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/advertised-peer/auto-negotiate
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_peer_auto_negotiate_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    boolean auto_negotiate;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_peer_auto_negotiate_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the auto_negotiate var here, change TRUE if needed */
    auto_negotiate = TRUE;VAL_BOOL(dstval) = auto_negotiate;

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_peer_auto_negotiate_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_peer_medium_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/advertised-peer/medium
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_peer_medium_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *medium;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_peer_medium_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the medium var here, change enum */
    medium = (const xmlChar *)"copper";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        medium);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_peer_medium_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_peer_pause_get
* 
* Get database object callback
* Path: /capable-switch/resources/port/features/advertised-peer/pause
* Fill in 'dstval' contents
* 
* INPUTS:
*     see ncx/getcb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_advertised_peer_pause_get (
    ses_cb_t *scb,
    getcb_mode_t cbmode,
    const val_value_t *virval,
    val_value_t *dstval)
{
    status_t res = NO_ERR;
    const xmlChar *pause;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_advertised_peer_pause_get callback");
    }


    /* remove the next line if scb is used */
    (void)scb;

    /* remove the next line if virval is used */
    (void)virval;

    if (cbmode != GETCB_GET_VALUE) {
        return ERR_NCX_OPERATION_NOT_SUPPORTED;
    }

    /* set the pause var here, change enum */
    pause = (const xmlChar *)"unsupported";
    res = val_set_simval_obj(
        dstval,
        dstval->obj,
        pause);

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_peer_pause_get */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_advertised_peer_mro
* 
* Make read-only child nodes
* Path: /capable-switch/resources/port/features/advertised-peer
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    onf_config1_1_capable_switch_resources_port_features_advertised_peer_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    /* container advertised-peer not handled!!! */

    /* add /capable-switch/resources/port/features/advertised-peer/auto-negotiate */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_auto_negotiate,
        onf_config1_1_capable_switch_resources_port_features_advertised_peer_auto_negotiate_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }
    /* container advertised-peer not handled!!! */

    /* add /capable-switch/resources/port/features/advertised-peer/pause */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_pause,
        onf_config1_1_capable_switch_resources_port_features_advertised_peer_pause_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    return res;

} /* onf_config1_1_capable_switch_resources_port_features_advertised_peer_mro */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_mro
* 
* Make read-only child nodes
* Path: /capable-switch/resources/port/features
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    onf_config1_1_capable_switch_resources_port_features_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    
    res = agt_add_container(
        y_onf_config1_1_M_onf_config1_1,
        y_onf_config1_1_N_current,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = onf_config1_1_capable_switch_resources_port_features_current_mro(childval);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_add_container(
        y_onf_config1_1_M_onf_config1_1,
        y_onf_config1_1_N_supported,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = onf_config1_1_capable_switch_resources_port_features_supported_mro(childval);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_add_container(
        y_onf_config1_1_M_onf_config1_1,
        y_onf_config1_1_N_advertised_peer,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = onf_config1_1_capable_switch_resources_port_features_advertised_peer_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* onf_config1_1_capable_switch_resources_port_features_mro */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_features_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/features
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_features_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_features_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = onf_config1_1_capable_switch_resources_port_features_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_features_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/tunnel/tunnel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_checksum_present_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/checksum-present
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_checksum_present_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_checksum_present_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_checksum_present_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_present_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/key-present
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_present_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_present_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_present_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/key
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_sequence_number_present_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/sequence-number-present
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_sequence_number_present_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_sequence_number_present_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_sequence_number_present_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_valid_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni-valid
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_valid_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_valid_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_valid_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_multicast_group_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni-multicast-group
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_multicast_group_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_multicast_group_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_multicast_group_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_source_port_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-source-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_source_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_source_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_source_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_dest_port_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-dest-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_dest_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_dest_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_dest_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_checksum_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-checksum
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_checksum_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_checksum_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_checksum_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_user_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni-user
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_user_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_user_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_user_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_multicast_group_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni-multicast-group
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_multicast_group_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_multicast_group_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_multicast_group_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_edit */

/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_mro
* 
* Make read-only child nodes
* Path: /capable-switch/resources/port
* 
* INPUTS:
*     parentval == the parent struct to use for new child nodes
* 
* RETURNS:
*     error status
********************************************************************/
static status_t
    onf_config1_1_capable_switch_resources_port_mro (val_value_t *parentval)
{
    status_t res = NO_ERR;
    val_value_t *childval = NULL;
    

    /* add /capable-switch/resources/port/number */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_number,
        onf_config1_1_capable_switch_resources_port_number_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/name */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_name,
        onf_config1_1_capable_switch_resources_port_name_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/current-rate */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_current_rate,
        onf_config1_1_capable_switch_resources_port_current_rate_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }

    /* add /capable-switch/resources/port/max-rate */
    childval = agt_make_virtual_leaf(
        parentval->obj,
        y_onf_config1_1_N_max_rate,
        onf_config1_1_capable_switch_resources_port_max_rate_get,
        &res);
    if (childval != NULL) {
        val_add_child(childval, parentval);
    } else {
        return res;
    }
    res = agt_add_container(
        y_onf_config1_1_M_onf_config1_1,
        y_onf_config1_1_N_state,
        parentval,
        &childval);
    if (res != NO_ERR) {
        return res;
    }

    res = onf_config1_1_capable_switch_resources_port_state_mro(childval);
    if (res != NO_ERR) {
        return res;
    }


    return res;

} /* onf_config1_1_capable_switch_resources_port_mro */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_port_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        if (res == NO_ERR && curval == NULL) {
            res = onf_config1_1_capable_switch_resources_port_mro(newval);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_resource_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/resource-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_resource_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_resource_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_resource_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_port_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_properties_min_rate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/properties/min-rate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_properties_min_rate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_properties_min_rate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_properties_min_rate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_properties_max_rate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/properties/max-rate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_properties_max_rate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_properties_max_rate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_properties_max_rate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_properties_experimenter_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/properties/experimenter
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_properties_experimenter_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_properties_experimenter_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_properties_experimenter_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_properties_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue/properties
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_properties_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_properties_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_properties_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_queue_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/queue
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_queue_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_queue_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_queue_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_resource_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/resource-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_resource_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_resource_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_resource_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_certificate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/certificate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_certificate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_certificate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_certificate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_P_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/P
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_P_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_P_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_P_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Q_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Q
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Q_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Q_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Q_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_J_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/J
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_J_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_J_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_J_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_G_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/G
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_G_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_G_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_G_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Y_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Y
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Y_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Y_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Y_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Seed_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Seed
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Seed_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Seed_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Seed_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_PgenCounter_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/PgenCounter
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_PgenCounter_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_PgenCounter_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_PgenCounter_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Modulus_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue/Modulus
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Modulus_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Modulus_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Modulus_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Exponent_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue/Exponent
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Exponent_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Exponent_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Exponent_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_private_key_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate/private-key
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_private_key_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_private_key_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_private_key_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_owned_certificate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/owned-certificate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_owned_certificate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_owned_certificate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_owned_certificate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_external_certificate_resource_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/external-certificate/resource-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_external_certificate_resource_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_external_certificate_resource_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_external_certificate_resource_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_external_certificate_certificate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/external-certificate/certificate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_external_certificate_certificate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_external_certificate_certificate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_external_certificate_certificate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_external_certificate_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/external-certificate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_external_certificate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_external_certificate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_external_certificate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_resource_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/resource-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_resource_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_resource_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_resource_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_max_entries_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/max-entries
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_max_entries_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_max_entries_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_max_entries_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_next_tables_table_id_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/next-tables/table-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_next_tables_table_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_next_tables_table_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_next_tables_table_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_next_tables_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/next-tables
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_next_tables_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_next_tables_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_next_tables_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_instructions_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/instructions/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_instructions_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_instructions_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_instructions_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_instructions_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/instructions
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_instructions_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_instructions_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_instructions_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_matches_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/matches/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_matches_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_matches_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_matches_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_matches_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/matches
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_matches_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_matches_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_matches_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_write_actions_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/write-actions/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_write_actions_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_write_actions_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_write_actions_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_write_actions_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/write-actions
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_write_actions_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_write_actions_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_write_actions_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_apply_actions_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/apply-actions/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_apply_actions_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_apply_actions_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_apply_actions_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_apply_actions_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/apply-actions
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_apply_actions_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_apply_actions_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_apply_actions_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_write_setfields_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/write-setfields/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_write_setfields_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_write_setfields_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_write_setfields_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_write_setfields_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/write-setfields
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_write_setfields_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_write_setfields_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_write_setfields_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_apply_setfields_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/apply-setfields/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_apply_setfields_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_apply_setfields_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_apply_setfields_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_apply_setfields_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/apply-setfields
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_apply_setfields_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_apply_setfields_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_apply_setfields_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_wildcards_type_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/wildcards/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_wildcards_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_wildcards_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_wildcards_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_wildcards_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/wildcards
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_wildcards_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_wildcards_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_wildcards_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_metadata_match_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/metadata-match
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_metadata_match_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_metadata_match_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_metadata_match_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_metadata_write_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table/metadata-write
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_metadata_write_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_metadata_write_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_metadata_write_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_flow_table_edit
* 
* Edit database object callback
* Path: /capable-switch/resources/flow-table
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_flow_table_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_flow_table_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_flow_table_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_resources_edit
* 
* Edit database object callback
* Path: /capable-switch/resources
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_resources_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_resources_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_resources_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_id_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_buffered_packets_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/max-buffered-packets
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_buffered_packets_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_buffered_packets_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_buffered_packets_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_tables_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/max-tables
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_tables_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_tables_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_tables_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_ports_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/max-ports
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_ports_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_ports_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_flow_statistics_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/flow-statistics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_flow_statistics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_flow_statistics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_flow_statistics_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_table_statistics_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/table-statistics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_table_statistics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_table_statistics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_table_statistics_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_port_statistics_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/port-statistics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_port_statistics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_port_statistics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_port_statistics_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_statistics_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/group-statistics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_statistics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_statistics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_statistics_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_queue_statistics_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/queue-statistics
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_queue_statistics_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_queue_statistics_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_queue_statistics_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_reassemble_ip_fragments_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/reassemble-ip-fragments
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_reassemble_ip_fragments_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_reassemble_ip_fragments_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_reassemble_ip_fragments_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_block_looping_ports_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/block-looping-ports
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_block_looping_ports_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_block_looping_ports_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_block_looping_ports_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_type_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/reserved-port-types/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/reserved-port-types
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_type_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/group-types/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/group-types
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_capability_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/group-capabilities/capability
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_capability_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_capability_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_capability_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/group-capabilities
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_type_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/action-types/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/action-types
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_type_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/instruction-types/type
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_type_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_type_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_type_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities/instruction-types
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_capabilities_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/capabilities
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_capabilities_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_capabilities_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_capabilities_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_datapath_id_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/datapath-id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_datapath_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_datapath_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_datapath_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_enabled_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/enabled
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_enabled_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_enabled_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_enabled_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_id_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/id
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_id_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_id_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_id_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_role_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/role
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_role_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_role_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_role_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_ip_address_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/ip-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_ip_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;
    
    printf("\nhebele\n");
    val_dump_value(curval,0);
    val_dump_value(newval,0);

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_ip_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_ip_address_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_port_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_ip_address_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/local-ip-address
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_ip_address_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_ip_address_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_ip_address_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_port_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/local-port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_protocol_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/protocol
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_protocol_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_protocol_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_protocol_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_connection_state_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/state/connection-state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_connection_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_connection_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_connection_state_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_current_version_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/state/current-version
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_current_version_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_current_version_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_current_version_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_supported_versions_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/state/supported-versions
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_supported_versions_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_supported_versions_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_supported_versions_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller/state
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers/controller
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_controllers_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/controllers
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_controllers_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_controllers_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_controllers_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_resources_port_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/resources/port
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_resources_port_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_resources_port_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_resources_port_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_resources_queue_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/resources/queue
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_resources_queue_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_resources_queue_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_resources_queue_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_resources_certificate_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/resources/certificate
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_resources_certificate_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_resources_certificate_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_resources_certificate_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_resources_flow_table_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/resources/flow-table
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_resources_flow_table_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_resources_flow_table_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_resources_flow_table_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_resources_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch/resources
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_resources_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_resources_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_resources_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_switch_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches/switch
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_switch_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_switch_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_switch_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_logical_switches_edit
* 
* Edit database object callback
* Path: /capable-switch/logical-switches
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_logical_switches_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_logical_switches_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_logical_switches_edit */


/********************************************************************
* FUNCTION onf_config1_1_capable_switch_edit
* 
* Edit database object callback
* Path: /capable-switch
* Add object instrumentation in COMMIT phase.
* 
* INPUTS:
*     see agt/agt_cb.h for details
* 
* RETURNS:
*     error status
********************************************************************/
static status_t onf_config1_1_capable_switch_edit (
    ses_cb_t *scb,
    rpc_msg_t *msg,
    agt_cbtyp_t cbtyp,
    op_editop_t editop,
    val_value_t *newval,
    val_value_t *curval)
{
    status_t res = NO_ERR;
    val_value_t *errorval = (curval) ? curval : newval;

    if (LOGDEBUG) {
        log_debug("\nEnter onf_config1_1_capable_switch_edit callback for %s phase",
            agt_cbtype_name(cbtyp));
    }

    switch (cbtyp) {
    case AGT_CB_VALIDATE:
        /* description-stmt validation here */
        break;
    case AGT_CB_APPLY:
        /* database manipulation done here */
        break;
    case AGT_CB_COMMIT:
        /* device instrumentation done here */
        switch (editop) {
        case OP_EDITOP_LOAD:
            break;
        case OP_EDITOP_MERGE:
            break;
        case OP_EDITOP_REPLACE:
            break;
        case OP_EDITOP_CREATE:
            break;
        case OP_EDITOP_DELETE:
            break;
        default:
            res = SET_ERROR(ERR_INTERNAL_VAL);
        }

        if (res == NO_ERR) {
            res = agt_check_cache(&capable_switch_val, newval, curval, editop);
        }
        
        break;
    case AGT_CB_ROLLBACK:
        /* undo device instrumentation here */
        break;
    default:
        res = SET_ERROR(ERR_INTERNAL_VAL);
    }

    if (res != NO_ERR) {
        agt_record_error(
            scb,
            &msg->mhdr,
            NCX_LAYER_CONTENT,
            res,
            NULL,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval,
            (errorval) ? NCX_NT_VAL : NCX_NT_NONE,
            errorval);
    }
    return res;

} /* onf_config1_1_capable_switch_edit */

/********************************************************************
* FUNCTION y_onf_config1_1_init
* 
* initialize the onf-config1.1 server instrumentation library
* 
* INPUTS:
*    modname == requested module name
*    revision == requested version (NULL for any)
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_onf_config1_1_init (
    const xmlChar *modname,
    const xmlChar *revision)
{
    status_t res = NO_ERR;
    agt_profile_t *agt_profile = agt_get_profile();

    y_onf_config1_1_init_static_vars();

    /* change if custom handling done */
    if (xml_strcmp(modname, y_onf_config1_1_M_onf_config1_1)) {
        return ERR_NCX_UNKNOWN_MODULE;
    }

    if (revision && xml_strcmp(revision, y_onf_config1_1_R_onf_config1_1)) {
        return ERR_NCX_WRONG_VERSION;
    }
    res = ncxmod_load_module(
        y_onf_config1_1_M_onf_config1_1,
        y_onf_config1_1_R_onf_config1_1,
        &agt_profile->agt_savedevQ,
        &onf_config1_1_mod);
    if (res != NO_ERR) {
        return res;
    }

    capable_switch_obj = ncx_find_object(
        onf_config1_1_mod,
        y_onf_config1_1_N_capable_switch);
    if (onf_config1_1_mod == NULL) {
        return SET_ERROR(ERR_NCX_DEF_NOT_FOUND);
    }
    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_configuration_points_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_configuration_points_configuration_point_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point/id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_configuration_points_configuration_point_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point/uri",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_configuration_points_configuration_point_uri_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point/protocol",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_configuration_points_configuration_point_protocol_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/resource-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_resource_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_configuration_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/admin-state",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_configuration_admin_state_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/no-receive",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_configuration_no_receive_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/no-forward",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_configuration_no_forward_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/no-packet-in",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_configuration_no_packet_in_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_features_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_features_advertised_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/rate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_features_advertised_rate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/auto-negotiate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_features_advertised_auto_negotiate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/medium",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_features_advertised_medium_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/pause",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_features_advertised_pause_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_tunnel_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/checksum-present",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_checksum_present_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/key-present",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_present_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/key",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_key_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/sequence-number-present",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_ipgre_tunnel_ipgre_tunnel_sequence_number_present_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni-valid",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_valid_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni-multicast-group",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_vni_multicast_group_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-source-port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_source_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-dest-port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_dest_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-checksum",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_vxlan_tunnel_vxlan_tunnel_udp_checksum_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv4_adress_local_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_ipv6_adress_local_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_local_endpoint_address_local_endpoint_mac_adress_local_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv4_adress_remote_endpoint_ipv4_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_ipv6_adress_remote_endpoint_ipv6_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_remote_endpoint_address_remote_endpoint_mac_adress_remote_endpoint_mac_adress_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni-user",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_user_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni-multicast-group",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_port_tunnel_type_nvgre_tunnel_nvgre_tunnel_tni_multicast_group_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/resource-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_resource_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_properties_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties/min-rate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_properties_min_rate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties/max-rate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_properties_max_rate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties/experimenter",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_queue_properties_experimenter_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/resource-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_resource_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/certificate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_certificate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/P",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_P_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Q",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Q_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/J",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_J_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/G",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_G_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Y",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Y_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Seed",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_Seed_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/PgenCounter",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_dsa_DSAKeyValue_PgenCounter_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue/Modulus",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Modulus_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue/Exponent",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_owned_certificate_private_key_key_type_rsa_RSAKeyValue_Exponent_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/external-certificate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_external_certificate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/external-certificate/resource-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_external_certificate_resource_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/external-certificate/certificate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_external_certificate_certificate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/resource-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_resource_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/max-entries",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_max_entries_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/next-tables",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_next_tables_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/next-tables/table-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_next_tables_table_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/instructions",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_instructions_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/instructions/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_instructions_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/matches",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_matches_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/matches/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_matches_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-actions",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_write_actions_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-actions/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_write_actions_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-actions",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_apply_actions_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-actions/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_apply_actions_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-setfields",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_write_setfields_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-setfields/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_write_setfields_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-setfields",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_apply_setfields_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-setfields/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_apply_setfields_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/wildcards",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_wildcards_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/wildcards/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_wildcards_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/metadata-match",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_metadata_match_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/metadata-write",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_resources_flow_table_metadata_write_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/max-buffered-packets",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_buffered_packets_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/max-tables",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_tables_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/max-ports",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_max_ports_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/flow-statistics",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_flow_statistics_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/table-statistics",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_table_statistics_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/port-statistics",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_port_statistics_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-statistics",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_statistics_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/queue-statistics",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_queue_statistics_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/reassemble-ip-fragments",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_reassemble_ip_fragments_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/block-looping-ports",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_block_looping_ports_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/reserved-port-types",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/reserved-port-types/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_reserved_port_types_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-types",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-types/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_types_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-capabilities",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-capabilities/capability",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_group_capabilities_capability_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/action-types",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/action-types/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_action_types_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/instruction-types",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/instruction-types/type",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_capabilities_instruction_types_type_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/datapath-id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_datapath_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/enabled",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_enabled_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/id",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_id_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/role",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_role_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/ip-address",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_ip_address_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/local-ip-address",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_ip_address_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/local-port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_local_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/protocol",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_protocol_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state/connection-state",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_connection_state_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state/current-version",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_current_version_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state/supported-versions",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_controllers_controller_state_supported_versions_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_resources_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/port",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_resources_port_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/queue",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_resources_queue_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/certificate",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_resources_certificate_edit);
    if (res != NO_ERR) {
        return res;
    }

    res = agt_cb_register_callback(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/flow-table",
        y_onf_config1_1_R_onf_config1_1,
        onf_config1_1_capable_switch_logical_switches_switch_resources_flow_table_edit);
    if (res != NO_ERR) {
        return res;
    }

    /* put your module initialization code here */
    
    return res;
} /* y_onf_config1_1_init */

/********************************************************************
* FUNCTION y_onf_config1_1_init2
* 
* SIL init phase 2: non-config data structures
* Called after running config is loaded
* 
* RETURNS:
*     error status
********************************************************************/
status_t y_onf_config1_1_init2 (void)
{
    status_t res = NO_ERR;

    capable_switch_val = agt_init_cache(
        y_onf_config1_1_M_onf_config1_1,
        y_onf_config1_1_N_capable_switch,
        &res);
    if (res != NO_ERR) {
        return res;
    }

    /* put your init2 code here */

    return res;
} /* y_onf_config1_1_init2 */

/********************************************************************
* FUNCTION y_onf_config1_1_cleanup
*    cleanup the server instrumentation library
* 
********************************************************************/
void y_onf_config1_1_cleanup (void)
{
    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point/id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point/uri");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/configuration-points/configuration-point/protocol");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/resource-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/admin-state");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/no-receive");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/no-forward");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/configuration/no-packet-in");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/rate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/auto-negotiate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/medium");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/features/advertised/pause");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/tunnel/tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/checksum-present");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/key-present");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/key");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/ipgre-tunnel/ipgre-tunnel/sequence-number-present");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni-valid");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/vni-multicast-group");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-source-port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-dest-port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/vxlan-tunnel/vxlan-tunnel/udp-checksum");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-ipv4-adress/local-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-ipv6-adress/local-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/local-endpoint-address/local-endpoint-mac-adress/local-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-ipv4-adress/remote-endpoint-ipv4-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-ipv6-adress/remote-endpoint-ipv6-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/remote-endpoint-address/remote-endpoint-mac-adress/remote-endpoint-mac-adress");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni-user");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/port/tunnel-type/nvgre-tunnel/nvgre-tunnel/tni-multicast-group");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/resource-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties/min-rate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties/max-rate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/queue/properties/experimenter");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/resource-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/certificate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/P");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Q");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/J");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/G");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Y");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/Seed");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/dsa/DSAKeyValue/PgenCounter");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue/Modulus");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/owned-certificate/private-key/key-type/rsa/RSAKeyValue/Exponent");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/external-certificate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/external-certificate/resource-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/external-certificate/certificate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/resource-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/max-entries");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/next-tables");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/next-tables/table-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/instructions");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/instructions/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/matches");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/matches/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-actions");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-actions/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-actions");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-actions/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-setfields");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/write-setfields/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-setfields");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/apply-setfields/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/wildcards");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/wildcards/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/metadata-match");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/resources/flow-table/metadata-write");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/max-buffered-packets");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/max-tables");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/max-ports");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/flow-statistics");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/table-statistics");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/port-statistics");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-statistics");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/queue-statistics");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/reassemble-ip-fragments");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/block-looping-ports");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/reserved-port-types");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/reserved-port-types/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-types");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-types/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-capabilities");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/group-capabilities/capability");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/action-types");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/action-types/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/instruction-types");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/capabilities/instruction-types/type");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/datapath-id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/enabled");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/id");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/role");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/ip-address");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/local-ip-address");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/local-port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/protocol");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state/connection-state");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state/current-version");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/controllers/controller/state/supported-versions");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/port");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/queue");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/certificate");

    agt_cb_unregister_callbacks(
        y_onf_config1_1_M_onf_config1_1,
        (const xmlChar *)"/capable-switch/logical-switches/switch/resources/flow-table");

    /* put your cleanup code here */
    
} /* y_onf_config1_1_cleanup */

/* END onf_config1_1.c */
